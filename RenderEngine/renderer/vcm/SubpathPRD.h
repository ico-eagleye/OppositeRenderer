/* 
 * Copyright (c) 2014 Opposite Renderer
 * For the full copyright and license information, please view the LICENSE.txt
 * file that was distributed with this source code.
 *
 * Contributions: Valdis Vilcans
*/

#pragma once
#include "renderer/RandomState.h"
#include <optix.h>
#include <optixu/optixu_math_namespace.h>
#include "renderer/vcm/config_vcm.h"

struct SubpathPRD
{
    optix::float3 origin;
    optix::float3 direction;
    optix::float3 throughput;
    optix::float3 color;        // accumulated full path contributions
    uint2 launchIndex;
    optix::uint depth;
    RandomState randomState;
    float dVCM;
    float dVC;
    float dVM;
#if VCM_UNIFORM_VERTEX_SAMPLING
    float dVC_unif_vert;       // dVC for uniform connection vertex sampling, account for vertex pick probability
#endif
    bool done;
    bool isGenByFiniteLight;          // Just generated by finite light
    bool isSpecularPath;  // All scattering events so far were specular
};

//#define VPRD_FROM_FINITE_LIGHT (1<<31u) // Just generated by finite light
//#define VPRD_SPECULAR_PATH (1<<30u)     // All scattering events so far were specular
//
//RT_FUNCTION optix::uint flagCheck(const optix::uint flag, const optix::uint checkFlag)
//{
//    return flag & checkFlag;
//}
//
//RT_FUNCTION void flagSet(optix::uint &flag, const optix::uint setFlag)
//{
//    flag |= setFlag;
//}
//
//RT_FUNCTION void flagClear(optix::uint &flag)
//{
//    flag = 0u;
//}